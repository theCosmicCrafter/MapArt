<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Generate customizable, high-quality map posters for any city in the world using OpenStreetMap data. Premium designs, multiple themes, and art styles available.">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: file:; connect-src 'self';">
  <title>Map Art Generator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&display=swap">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Open+Sans:wght@400;700&family=Montserrat:wght@400;700&family=Playfair+Display:wght@400;700&family=Oswald:wght@400;700&family=Raleway:wght@400;700&family=Lato:wght@400;700&family=Bebas+Neue&family=Anton&family=Rubik:wght@400;700&display=swap">
  <link rel="stylesheet" href="assets/css/styles.css">
</head>
<body data-theme="synth">
  <div class="chrome">
    <header>
      <div class="title" id="debug-toggle" title="Click to toggle debug log">Map Art Generator</div>
      <div class="header-status-group">
          <div class="queue-badge" id="queue-counter">AQ: 0</div>
          <div class="status" id="status-msg"><span class="status-dot"></span>Systems Nominal · Output saves to /outputs</div>
      </div>
    </header>

    <div class="progress-card">
      <h3>Render Progress</h3>
      <p class="hint">Tracks the current render pass. Use as a visual guide while maps generate.</p>
      <div class="progress-track">
        <div class="progress-fill" id="progress-fill"></div>
      </div>
      <div class="progress-label"><span id="progress-text">Idle</span><span id="progress-value">0%</span></div>
    </div>

    <main class="panel-grid">
      <section class="stack">
        <article class="card card-tight">
          <h3>Input Vector</h3>
          <p class="hint">Enter the city + country for your map art (e.g., “Barcelona, Spain”). Press Enter or hit Execute to render.</p>
          <div class="field">
            <label for="city">City / Target</label>
            <div class="input-wrap">
              <div class="glow-ring"></div>
              <input id="city" class="neon-input" placeholder="Barcelona, Spain" />
            </div>
            <div class="error-hint" id="city-error" aria-live="polite"></div>
          </div>
          <div class="field">
            <div class="pill">Tip: Enter city, adjust controls, then Execute Pulse to render into /outputs</div>
            <div class="cta-right">
              <div class="status-pill" id="selection-pill">Theme: <strong id="pill-theme">feature_based</strong> · Font: <strong id="pill-font">Roboto</strong></div>
              <button class="btn" id="execute-btn" disabled>Execute Pulse</button>
            </div>
          </div>
        </article>

        <article class="card">
          <h3>Output Viewer</h3>
          <p class="hint">Newest map poster is saved to /outputs. Refresh after Execute to view the latest render.</p>
          <div class="viewer">
            <div class="viewer-frame">
              <img id="output-img" class="output-img" alt="Generated map poster preview" />
              <div class="viewer-grid"></div>
              <div class="viewer-overlay"></div>
              <button class="folder-btn" id="open-folder-btn" title="Open Output Folder">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                </svg>
              </button>
            </div>
            <div class="viewer-label">Tip: Generated poster appears here after Execute. Filenames include city + theme + timestamp.</div>
          </div>
        </article>
      </section>

      <section class="stack">
        <article class="card">
          <h3>Generation Controls</h3>
          <p class="hint">Set generation parameters. Theme maps to CLI --theme; distance sets radius in meters; width/height are inches; format is output type.</p>
          <div class="field field-tight">
            <div class="field">
              <label>Map Type</label>
              <div class="map-type-toggle" id="map-type-toggle">
                <button class="map-type-btn active" data-type="city">City</button>
                <button class="map-type-btn" data-type="railway">Railway</button>
                <button class="map-type-btn" data-type="cycling">Cycling</button>
                <button class="map-type-btn" data-type="transit">Transit</button>
                <button class="map-type-btn" data-type="maritime">Maritime</button>
              </div>
            </div>
            <div class="field">
              <label>Theme</label>
              <div class="theme-chip-row" id="theme-chips"></div>
              <div class="theme-preview" id="theme-preview">Hover or select a theme to see its style notes.</div>
            </div>
            <div class="field">
              <label for="texture-select">Paper Texture</label>
              <select id="texture-select" class="neon-input select" title="Select paper texture for the map">
                <option value="none">None</option>
                <optgroup label="Base Papers">
                  <option value="archival_cotton_rag">Archival Cotton Rag</option>
                  <option value="cold_press_bright">Cold Press Bright</option>
                  <option value="heavy_cold_press">Heavy Cold Press</option>
                  <option value="white_linen_canvas">White Linen Canvas</option>
                  <option value="stippled_gesso">Stippled Gesso</option>
                  <option value="clean_stucco_wall">Clean Stucco Wall</option>
                  <option value="white_recycled_bond">White Recycled Bond</option>
                  <option value="clean_recycled_speckle">Clean Recycled Speckle</option>
                  <option value="vintage_sage_cardstock">Vintage Sage Cardstock</option>
                  <option value="wavy_gold_cardstock">Wavy Gold Cardstock</option>
                  <option value="recycled_greyboard">Recycled Greyboard</option>
                  <option value="recycled_bond_grey">Recycled Bond Grey</option>
                  <option value="rough_grey_pulp">Rough Grey Pulp</option>
                  <option value="slate_concrete">Slate Concrete</option>
                  <option value="spalted_wood_grain">Spalted Wood Grain</option>
                </optgroup>
                <optgroup label="Specialty Papers">
                  <option value="foxed_parchment">Foxed Parchment</option>
                  <option value="folded_correspondence_a">Folded Correspondence A</option>
                  <option value="folded_correspondence_b">Folded Correspondence B</option>
                  <option value="pale_blue_folded">Pale Blue Folded</option>
                  <option value="taped_spine_binding">Taped Spine Binding</option>
                  <option value="water_damaged_ledger">Water Damaged Ledger</option>
                  <option value="crumpled_tissue_beige">Crumpled Tissue Beige</option>
                  <option value="raw_packing_kraft">Raw Packing Kraft</option>
                  <option value="clean_kraft_cardstock">Clean Kraft Cardstock</option>
                  <option value="oiled_kraft_dark">Oiled Kraft Dark</option>
                  <option value="collage_scraps">Collage Scraps</option>
                  <option value="corrugated_tear">Corrugated Tear</option>
                  <option value="forest_buckram">Forest Buckram</option>
                  <option value="crimson_library_cloth">Crimson Library Cloth</option>
                  <option value="antique_book_cloth">Antique Book Cloth</option>
                  <option value="bronze_suede_sepia">Bronze Suede Sepia</option>
                  <option value="dark_weave_charcoal">Dark Weave Charcoal</option>
                </optgroup>
                <optgroup label="Artistic Effects">
                  <option value="gothic_ink_frame">Gothic Ink Frame</option>
                  <option value="wet_wash_watercolor">Wet Wash Watercolor</option>
                  <option value="split_tone_wall_overlay">Split Tone Wall Overlay</option>
                  <option value="frosted_acetate">Frosted Acetate</option>
                  <option value="spray_noise_overlay">Spray Noise Overlay</option>
                  <option value="high_contrast_stone">High Contrast Stone</option>
                  <option value="metallic_gold_grain">Metallic Gold Grain</option>
                  <option value="film_grain_gradient">Film Grain Gradient</option>
                </optgroup>
                <optgroup label="Stains & Decay">
                  <option value="heavy_coffee_staining">Heavy Coffee Staining</option>
                  <option value="black_mold_decay">Black Mold Decay</option>
                  <option value="white_lead_decay">White Lead Decay</option>
                  <option value="industrial_slate_decay">Industrial Slate Decay</option>
                  <option value="urban_concrete_decay">Urban Concrete Decay</option>
                </optgroup>
                <optgroup label="Edge Treatments">
                  <option value="crushed_bond_white">Crushed Bond White</option>
                  <option value="crushed_bond_var_a">Crushed Bond Var A</option>
                  <option value="crushed_bond_var_b">Crushed Bond Var B</option>
                </optgroup>
              </select>
            </div>
            
            <!-- STYLE MIXER -->
            <div class="field mixer-section">
              <div class="mixer-header">
                <label for="enable-mixer" class="mixer-label">Style Mixer</label>
                <div class="toggle-switch">
                  <input type="checkbox" id="enable-mixer" />
                  <label for="enable-mixer" class="toggle-track"></label>
                </div>
              </div>
              
              <div id="mixer-controls" class="mixer-controls-panel">
                <div class="field compact">
                   <label>Roads Style</label>
                   <select id="style-roads" class="neon-input select compact" title="Select custom style for roads">
                     <option value="">(From Theme)</option>
                   </select>
                </div>
                <div class="field compact">
                   <label>Water Style</label>
                   <select id="style-water" class="neon-input select compact" title="Select custom style for water">
                     <option value="">(From Theme)</option>
                   </select>
                </div>
                <div class="field compact">
                   <label>Parks Style</label>
                   <select id="style-parks" class="neon-input select compact" title="Select custom style for parks">
                     <option value="">(From Theme)</option>
                   </select>
                </div>
                <div class="field compact">
                   <label>Transit Style</label>
                   <select id="style-transit" class="neon-input select compact" title="Select custom style for transit">
                     <option value="">(From Theme)</option>
                   </select>
                </div>
              </div>
            </div>
            <div class="field">
              <label for="map-shape">Map Shape</label>
              <select id="map-shape" class="neon-input select" title="Choose map shape">
                <option value="rectangle">Rectangle</option>
                <option value="circle">Circle</option>
                <option value="triangle">Triangle</option>
              </select>
            </div>
            <div class="field">
              <label for="artistic-effect">Artistic Effect</label>
              <select id="artistic-effect" class="neon-input select" title="Apply artistic effects to the map">
                <option value="none">None</option>
                <option value="watercolor">Watercolor</option>
                <option value="pencil_sketch">Pencil Sketch</option>
                <option value="oil_painting">Oil Painting</option>
                <option value="vintage">Vintage</option>
              </select>
            </div>
            <div class="field">
              <label for="color-enhancement">Color Enhancement</label>
              <select id="color-enhancement" class="neon-input select" title="Apply intelligent color enhancement">
                <option value="none">None</option>
                <option value="intelligent_palette">Intelligent Palette</option>
                <option value="geographic_colors">Geographic Colors</option>
                <option value="seasonal_summer">Summer Colors</option>
                <option value="seasonal_autumn">Autumn Colors</option>
                <option value="seasonal_winter">Winter Colors</option>
                <option value="seasonal_spring">Spring Colors</option>
              </select>
            </div>
            <div class="field">
              <label for="format">Format</label>
              <div class="input-wrap"><div class="glow-ring"></div>
                <select id="format" class="neon-input select">
                  <option value="png">PNG</option>
                  <option value="jpg">JPG</option>
                  <option value="jpeg">JPEG</option>
                  <option value="tiff">TIFF</option>
                  <option value="svg">SVG</option>
                  <option value="pdf">PDF</option>
                  <option value="eps">EPS</option>
                  <option value="ps">PostScript</option>
                </select>
              </div>
            </div>
            <div class="field">
              <label for="distance">Distance / Scale</label>
              <div class="distance-presets" id="distance-presets"></div>
              <div class="input-wrap">
                <div class="glow-ring"></div>
                <input id="distance" class="neon-input" type="number" value="29000" min="1000" step="500" />
              </div>
              <div class="scale-hint" id="scale-hint">City view: ~29km radius</div>
            </div>
            <div class="field">
              <label for="width">Size (W x H inches)</label>
              <div class="inline-pair">
                <div class="input-wrap flex-1">
                  <div class="glow-ring"></div>
                  <input id="width" class="neon-input" type="number" value="12" title="Width in inches" placeholder="12" min="1" step="0.5" />
                </div>
                <div class="input-wrap flex-1">
                  <div class="glow-ring"></div>
                  <input id="height" class="neon-input" type="number" value="16" title="Height in inches" placeholder="16" min="1" step="0.5" />
                </div>
                <button class="swap-btn" id="swap-size" type="button">Swap</button>
              </div>
            </div>
            <div class="field">
              <label>Font</label>
              <div class="font-chip-row" id="font-chips"></div>
              <div class="font-preview" id="font-preview">Hover or select a font to see how it looks.</div>
            </div>
          </div>
        </article>
      </section>
    </main>
  </div>
  
  <div class="debug-panel" id="debug-panel">
    <div class="debug-section">
      <label>UI Theme</label>
      <div class="ui-theme-row" id="ui-theme-chips"></div>
    </div>
    <div class="debug-entry">Debug log ready.</div>
    <div id="debug-log"></div>
  </div>
  
  <div class="toast-container" id="toast-container"></div>

  <script>
    const cityInput = document.getElementById('city');
    const themeChips = document.getElementById('theme-chips');
    const themePreview = document.getElementById('theme-preview');
    const fontChips = document.getElementById('font-chips');
    const fontPreview = document.getElementById('font-preview');
    const uiThemeChips = document.getElementById('ui-theme-chips');
    const textureSelect = document.getElementById('texture-select');
    const mapTypeToggle = document.getElementById('map-type-toggle');
    const distancePresets = document.getElementById('distance-presets');
    const scaleHint = document.getElementById('scale-hint');
    const mapShapeSelect = document.getElementById('map-shape');
    const artisticEffectSelect = document.getElementById('artistic-effect');
    const colorEnhancementSelect = document.getElementById('color-enhancement');
    const distanceInput = document.getElementById('distance');
    const widthInput = document.getElementById('width');
    const heightInput = document.getElementById('height');
    const formatInput = document.getElementById('format');
    const executeBtn = document.getElementById('execute-btn');
    const cityError = document.getElementById('city-error');
    const selectionPill = document.getElementById('selection-pill');
    const pillTheme = document.getElementById('pill-theme');
    const pillFont = document.getElementById('pill-font');
    const toastContainer = document.getElementById('toast-container');
    const swapSizeBtn = document.getElementById('swap-size');
    const statusMsg = document.getElementById('status-msg');


    let selectedTheme = 'feature_based';
    let selectedFont = 'Roboto';
    let selectedTexture = 'none';
    let selectedMapShape = 'rectangle';
    let selectedArtisticEffect = 'none';
    let selectedColorEnhancement = 'none';
    let selectedMapType = ['city'];
    const progressFill = document.getElementById('progress-fill');

    // Map type distance presets configuration
    const mapTypeDistanceConfig = {
      city: {
        default: 29000,
        presets: [
          { value: 5000, label: '5km', desc: 'Neighborhood' },
          { value: 15000, label: '15km', desc: 'District' },
          { value: 29000, label: '29km', desc: 'City' },
          { value: 50000, label: '50km', desc: 'Metro' },
        ],
        hint: 'City view radius'
      },
      railway: {
        default: 100000,
        presets: [
          { value: 50000, label: '50km', desc: 'Short haul' },
          { value: 100000, label: '100km', desc: 'Regional' },
          { value: 250000, label: '250km', desc: 'Intercity' },
          { value: 500000, label: '500km', desc: 'Long distance' },
        ],
        hint: 'Railway route span'
      },
      cycling: {
        default: 10000,
        presets: [
          { value: 5000, label: '5km', desc: 'Quick ride' },
          { value: 10000, label: '10km', desc: 'Casual' },
          { value: 25000, label: '25km', desc: 'Tour' },
          { value: 50000, label: '50km', desc: 'Endurance' },
        ],
        hint: 'Cycling route distance'
      },
      transit: {
        default: 15000,
        presets: [
          { value: 5000, label: '5km', desc: 'Local' },
          { value: 10000, label: '10km', desc: 'Urban' },
          { value: 15000, label: '15km', desc: 'Citywide' },
          { value: 30000, label: '30km', desc: 'Regional' },
        ],
        hint: 'Transit system span'
      },
      maritime: {
        default: 200000,
        presets: [
          { value: 50000, label: '50km', desc: 'Coastal' },
          { value: 100000, label: '100km', desc: 'Harbor' },
          { value: 200000, label: '200km', desc: 'Regional' },
          { value: 500000, label: '500km', desc: 'Voyage' },
        ],
        hint: 'Maritime route span'
      }
    };

    const renderDistancePresets = (mapType) => {
      if (!distancePresets) return;
      const config = mapTypeDistanceConfig[mapType] || mapTypeDistanceConfig.city;
      
      distancePresets.innerHTML = '';
      config.presets.forEach(preset => {
        const btn = document.createElement('button');
        btn.className = 'distance-preset-btn';
        btn.textContent = preset.label;
        btn.title = `${preset.desc} - ${preset.value.toLocaleString()}m`;
        btn.addEventListener('click', () => {
          distanceInput.value = preset.value;
          if (scaleHint) scaleHint.textContent = `${config.hint}: ~${preset.label} ${preset.desc}`;
          saveInputs();
        });
        distancePresets.appendChild(btn);
      });
      
      // Update hint
      if (scaleHint) {
        const defaultPreset = config.presets.find(p => p.value === config.default) || config.presets[0];
        scaleHint.textContent = `${config.hint}: ~${defaultPreset.label} ${defaultPreset.desc}`;
      }
    };

    const applyMapTypeDefaults = (mapType) => {
      const config = mapTypeDistanceConfig[mapType] || mapTypeDistanceConfig.city;
      distanceInput.value = config.default;
      renderDistancePresets(mapType);
    };

    const progressText = document.getElementById('progress-text');
    const progressValue = document.getElementById('progress-value');
    const debugPanel = document.getElementById('debug-panel');
    const debugLog = document.getElementById('debug-log');
    const debugToggle = document.getElementById('debug-toggle');
    const outputImg = document.getElementById('output-img');
    const viewerFrame = document.querySelector('.viewer-frame');

    const setProgress = (pct, text) => {
      progressFill.style.width = `${pct}%`;
      progressValue.textContent = `${pct}%`;
      progressText.textContent = text;
    };

    const showToast = (type, message) => {
      if (!toastContainer) return;
      const div = document.createElement('div');
      div.className = `toast ${type}`;
      div.textContent = message;
      toastContainer.appendChild(div);
      setTimeout(() => {
        div.style.opacity = '0';
        div.style.transform = 'translateY(-4px)';
        setTimeout(() => div.remove(), 200);
      }, 2200);
    };

    const parseCityCountry = (input) => {
      if (!input) return { city: '', country: '' };
      
      const countries = ['USA', 'CANADA', 'UK', 'UNITED KINGDOM', 'FRANCE', 'GERMANY', 'ITALY', 'SPAIN', 'AUSTRALIA', 'MEXICO', 'JAPAN', 'CHINA', 'BRAZIL'];
      const parts = input.split(',').map(p => p.trim()).filter(Boolean);
      
      if (parts.length === 1) {
        const spaceParts = input.trim().split(/\s+/);
        if (spaceParts.length > 1) {
          const last = spaceParts[spaceParts.length - 1].toUpperCase();
          if (countries.includes(last) || (last === 'STATES' && spaceParts[spaceParts.length-2]?.toUpperCase() === 'UNITED')) {
            const country = (last === 'STATES') ? 'USA' : spaceParts[spaceParts.length - 1];
            const cityPart = (last === 'STATES') ? spaceParts.slice(0, -2) : spaceParts.slice(0, -1);
            return {
              city: cityPart.join(' '),
              country: country === 'US' || country === 'USA' ? 'USA' : country
            };
          }
        }
        
        // If only city is provided, assume USA for common US cities
        const city = parts[0];
        const commonUSCities = ['Raleigh', 'New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix', 'Philadelphia', 'San Antonio', 'San Diego', 'Dallas', 'San Jose', 'Austin', 'Jacksonville', 'Fort Worth', 'Columbus', 'Charlotte', 'San Francisco', 'Indianapolis', 'Seattle', 'Denver', 'Washington', 'Boston', 'El Paso', 'Nashville', 'Detroit', 'Oklahoma City', 'Portland', 'Las Vegas', 'Memphis', 'Louisville', 'Milwaukee', 'Baltimore', 'Albuquerque', 'Tucson', 'Fresno', 'Sacramento', 'Kansas City', 'Mesa', 'Atlanta', 'Omaha', 'Colorado Springs', 'Raleigh', 'Long Beach', 'Virginia Beach', 'Miami', 'Oakland', 'Minneapolis', 'Tampa', 'Tulsa', 'Arlington', 'Wichita', 'New Orleans', 'Bakersfield', 'Tampa', 'Honolulu', 'Anaheim', 'Santa Ana', 'Riverside', 'Corpus Christi', 'Lexington', 'Henderson', 'Stockton', 'St. Paul', 'Cincinnati', 'Greensboro', 'Pittsburgh', 'Lincoln', 'Anchorage', 'Plano', 'Orlando', 'Irvine', 'Newark', 'Durham', 'Chula Vista', 'Fort Wayne', 'Chandler', 'Laredo', 'Norfolk', 'Madison', 'Lubbock', 'Scottsdale', 'Garland', 'Gilbert', 'Reno', 'Glendale', 'Buffalo', 'North Las Vegas', 'Hialeah', 'Winston Salem', 'Chesapeake', 'Fremont', 'Irving', 'El Paso', 'Greensboro'];
        return { 
          city, 
          country: commonUSCities.includes(city) ? 'USA' : ''
        };
      }

      
      // Handle US states
      const usStates = ['AL','AK','AZ','AR','CA','CO','CT','DE','FL','GA','HI','ID','IL','IN','IA','KS','KY','LA','ME','MD','MA','MI','MN','MS','MO','MT','NE','NV','NH','NJ','NM','NY','NC','ND','OH','OK','OR','PA','RI','SC','SD','TN','TX','UT','VT','VA','WA','WV','WI','WY','DC'];
      
      if (parts.length >= 3) {
        const secondToLast = parts[parts.length - 2].toUpperCase();
        const last = parts[parts.length - 1].toUpperCase();
        
        if (usStates.includes(secondToLast) && (last === 'USA' || last === 'US' || last === 'UNITED STATES')) {
          return { 
            city: parts[0], 
            country: last === 'US' ? 'USA' : last,
            state: secondToLast
          };
        }
      }
      
      return { city: parts[0], country: parts.slice(1).join(', ') };
    };

    window.electronAPI?.onRenderProgress?.(({ pct, text }) => {
      if (typeof pct === 'number') {
        setProgress(Math.max(0, Math.min(100, Math.round(pct))), text || '');
      }
      if (pct >= 100 && outputImg) {
        setTimeout(async () => {
          const newestPath = await window.electronAPI.getNewestPoster();
          if (newestPath) {
            const fileUrl = 'file:///' + newestPath.replace(/\\/g, '/');
            outputImg.src = fileUrl;
            outputImg.style.display = 'block';
            if (debugLog) {
              const div = document.createElement('div');
              div.className = 'debug-entry';
              div.textContent = `Loading poster: ${fileUrl}`;
              debugLog.appendChild(div);
              debugLog.scrollTop = debugLog.scrollHeight;
            }
          } else {
            if (debugLog) {
              const div = document.createElement('div');
              div.className = 'debug-entry err';
              div.textContent = 'No poster file found to display.';
              debugLog.appendChild(div);
              debugLog.scrollTop = debugLog.scrollHeight;
            }
          }
        }, 500);
      }
    });

    window.electronAPI?.onRenderLog?.((entry) => {
      if (!debugLog || !entry) return;
      const div = document.createElement('div');
      div.className = `debug-entry ${entry.type === 'err' ? 'err' : ''}`;
      div.textContent = entry.chunk ?? '';
      debugLog.appendChild(div);
      debugLog.scrollTop = debugLog.scrollHeight;
    });

    const themesMeta = {
      feature_based: { desc: 'Classic black/white with road hierarchy.', img: 'assets/posters/new_york_feature_based_preview.jpg' },
      gradient_roads: { desc: 'Smooth gradients across primary roads.', img: 'assets/posters/new_york_gradient_roads_preview.jpg' },
      contrast_zones: { desc: 'High-contrast density shading.', img: 'assets/posters/new_york_contrast_zones_preview.jpg' },
      noir: { desc: 'True black backdrop, white roads.', img: 'assets/posters/new_york_noir_preview.jpg' },
      midnight_blue: { desc: 'Navy base with warm gold strokes.', img: 'assets/posters/new_york_midnight_blue_preview.jpg' },
      blueprint: { desc: 'Blueprint lines on cool blue.', img: 'assets/posters/new_york_blueprint_preview.jpg' },
      neon_cyberpunk: { desc: 'Electric pink/cyan on dark.', img: 'assets/posters/new_york_neon_cyberpunk_preview.jpg' },
      warm_beige: { desc: 'Vintage beige paper feel.', img: 'assets/posters/new_york_warm_beige_preview.jpg' },
      pastel_dream: { desc: 'Soft pastel palette.', img: 'assets/posters/new_york_pastel_dream_preview.jpg' },
      japanese_ink: { desc: 'Minimal ink wash aesthetic.', img: 'assets/posters/new_york_japanese_ink_preview.jpg' },
      forest: { desc: 'Deep greens and sage.', img: 'assets/posters/new_york_forest_preview.jpg' },
      ocean: { desc: 'Cool blues and teals.', img: 'assets/posters/new_york_ocean_preview.jpg' },
      terracotta: { desc: 'Mediterranean terracotta warmth.', img: 'assets/posters/new_york_terracotta_preview.jpg' },
      sunset: { desc: 'Oranges and pinks inspired by dusk.', img: 'assets/posters/new_york_sunset_preview.jpg' },
      autumn: { desc: 'Burnt oranges and reds.', img: 'assets/posters/new_york_autumn_preview.jpg' },
      copper_patina: { desc: 'Oxidized copper tones.', img: 'assets/posters/new_york_copper_patina_preview.jpg' },
      monochrome_blue: { desc: 'Single-family blue monochrome.', img: 'assets/posters/new_york_monochrome_blue_preview.jpg' },
      arctic_aurora: { desc: 'Northern lights with deep blue and aurora colors.', img: 'assets/posters/new_york_arctic_aurora_preview.jpg' },
      mars_colony: { desc: 'Red planet aesthetic with rusty oranges.', img: 'assets/posters/new_york_mars_colony_preview.jpg' },
      enchanted_forest: { desc: 'Deep greens with bioluminescent accents.', img: 'assets/posters/new_york_enchanted_forest_preview.jpg' },
      vintage_sepia: { desc: 'Old-world map with aged paper tones.', img: 'assets/posters/new_york_vintage_sepia_preview.jpg' },
      candy_land: { desc: 'Playful pastel colors like candy.', img: 'assets/posters/new_york_candy_land_preview.jpg' },
      matrix_code: { desc: 'Digital rain effect with greens on black.', img: 'assets/posters/new_york_matrix_code_preview.jpg' },
      sunset_boulevard: { desc: 'LA sunset vibes with warm gradients.', img: 'assets/posters/new_york_sunset_boulevard_preview.jpg' },
      ice_crystal: { desc: 'Frozen crystalline appearance.', img: 'assets/posters/new_york_ice_crystal_preview.jpg' },
      toxic_waste: { desc: 'Industrial hazard warning colors.', img: 'assets/posters/new_york_toxic_waste_preview.jpg' },
      royal_purple: { desc: 'Regal luxury with deep purples and golds.', img: 'assets/posters/new_york_royal_purple_preview.jpg' },
      watercolor: { desc: 'Soft, flowing watercolor aesthetic with artistic colors.', img: 'assets/posters/new_york_watercolor_preview.jpg' },
      pencil_sketch: { desc: 'Hand-drawn pencil sketch with grayscale tones.', img: 'assets/posters/new_york_pencil_sketch_preview.jpg' },
      ink_wash: { desc: 'East Asian ink wash art with black ink gradients.', img: 'assets/posters/new_york_ink_wash_preview.jpg' },
      oil_paint: { desc: 'Rich oil painting with vibrant colors and brush strokes.', img: 'assets/posters/new_york_oil_paint_preview.jpg' },
      mountain_watercolor: { desc: 'Soft watercolors perfect for mountain regions with elevation-based coloring.', img: 'assets/posters/new_york_mountain_watercolor_preview.jpg' },
      coastal_nautical: { desc: 'Nautical chart style with blues and sea-themed colors.', img: 'assets/posters/new_york_coastal_nautical_preview.jpg' },
      desert_oasis: { desc: 'Warm desert colors with oasis highlights.', img: 'assets/posters/new_york_desert_oasis_preview.jpg' },
      forest_enchanted: { desc: 'Lush forest theme with mystical green tones.', img: 'assets/posters/new_york_forest_enchanted_preview.jpg' },
      fantasy_ancient: { desc: 'Aged fantasy map with mystical elements.', img: 'assets/posters/new_york_fantasy_ancient_preview.jpg' },
      roman_britain: { desc: 'Imperial Roman roads with terracotta and gold.', img: 'assets/posters/new_york_roman_britain_preview.jpg' },
      feudal_japan: { desc: 'Traditional ink wash aesthetic.', img: 'assets/posters/new_york_feudal_japan_preview.jpg' },
      ming_dynasty: { desc: 'Imperial China with forbidden city colors.', img: 'assets/posters/new_york_ming_dynasty_preview.jpg' },
      american_revolution: { desc: 'Colonial America with patriotic colors.', img: 'assets/posters/new_york_american_revolution_preview.jpg' },
      gold_rush: { desc: 'Wild West with gold and frontier colors.', img: 'assets/posters/new_york_gold_rush_preview.jpg' },
    };

    const fontsList = [
      'Roboto', 'Open Sans', 'Montserrat', 'Playfair Display', 'Oswald', 'Raleway', 'Lato', 'Bebas Neue', 'Anton', 'Rubik',
      'Arial', 'Helvetica', 'Times New Roman', 'Georgia', 'Verdana', 'Courier New', 'Impact', 'Comic Sans MS'
    ];

    const renderThemePreview = (key) => {
      if (themePreview && themesMeta[key]) {
        const meta = themesMeta[key];
        const testImg = new Image();
        testImg.onload = () => {
          const img = new Image();
          img.onload = () => {
            themePreview.innerHTML = `<img src="${meta.img}" alt="${key}" /><div>${key}: ${meta.desc}</div>`;
          };
          img.onerror = () => {
            themePreview.innerHTML = `<div style="padding:8px;background:#1a1a2e;border-radius:8px;margin-bottom:8px;"><strong>${key}</strong></div><div>${meta.desc}</div>`;
          };
          img.src = meta.img;
        };
        testImg.onerror = () => {
          themePreview.innerHTML = `<div style="padding:8px;background:#1a1a2e;border-radius:8px;margin-bottom:8px;"><strong>${key}</strong></div><div>${meta.desc}</div>`;
        };
        testImg.src = 'assets/posters/new_york_feature_based_preview.jpg';
      }
    };

    const themeCategories = {
      modern: [
        'feature_based', 'gradient_roads', 'contrast_zones', 'noir', 'midnight_blue', 
        'blueprint', 'neon_cyberpunk', 'warm_beige', 'pastel_dream', 'japanese_ink',
        'forest', 'ocean', 'terracotta', 'sunset', 'autumn', 'copper_patina', 
        'monochrome_blue', 'arctic_aurora', 'mars_colony', 'enchanted_forest',
        'vintage_sepia', 'candy_land', 'matrix_code', 'sunset_boulevard', 
        'ice_crystal', 'toxic_waste', 'royal_purple', 'watercolor', 'pencil_sketch',
        'ink_wash', 'oil_paint', 'mountain_watercolor', 'coastal_nautical', 
        'desert_oasis', 'forest_enchanted', 'fantasy_ancient'
      ],
      historical: [
        'roman_britain', 'feudal_japan', 'ming_dynasty', 'american_revolution', 'gold_rush'
      ],
      fictional: []
    };

    const renderThemes = (mapType) => {
      if (!themeChips) return;
      themeChips.innerHTML = '';
      
      const themes = themeCategories[mapType] || themeCategories.modern;
      themes.forEach((key) => {
        if (themesMeta[key]) {
          const chip = document.createElement('div');
          chip.className = 'theme-chip';
          chip.textContent = key;
          chip.addEventListener('mouseenter', () => renderThemePreview(key));
          chip.addEventListener('click', () => {
            selectedTheme = key;
            document.querySelectorAll('.theme-chip').forEach(c => c.classList.remove('active'));
            chip.classList.add('active');
            renderThemePreview(key);
            if (pillTheme) pillTheme.textContent = key;
          });
          themeChips.appendChild(chip);
        }
      });
      
      const firstChip = themeChips.querySelector('.theme-chip');
      if (firstChip) {
        firstChip.classList.add('active');
      }
    };

    renderThemes('modern');
    
    // Populate Mixer Dropdowns
    const populateMixer = () => {
        const allThemes = [...themeCategories.modern, ...themeCategories.historical];
        ['style-roads', 'style-water', 'style-parks', 'style-transit'].forEach(id => {
            const select = document.getElementById(id);
            if (!select) return;
            allThemes.forEach(theme => {
                const opt = document.createElement('option');
                opt.value = theme;
                opt.textContent = theme.replace(/_/g, ' ').toUpperCase();
                select.appendChild(opt);
            });
        });
    };
    populateMixer();

    // Toggle Mixer Visibility
    const mixerToggle = document.getElementById('enable-mixer');
    const mixerControls = document.getElementById('mixer-controls');
    if (mixerToggle && mixerControls) {
        mixerToggle.addEventListener('change', (e) => {
            mixerControls.style.display = e.target.checked ? 'block' : 'none';
        });
    }

    const renderFontPreview = (font) => {
      if (fontPreview) {
        fontPreview.innerHTML = '';
        const title = document.createElement('div');
        title.className = 'font-preview-title';
        title.textContent = 'The quick brown fox';
        title.style.fontFamily = `'${font}', sans-serif`;
        const meta = document.createElement('div');
        meta.className = 'font-preview-meta';
        meta.textContent = `ABCDEF 123456 ${font}`;
        meta.style.fontFamily = `'${font}', sans-serif`;
        fontPreview.appendChild(title);
        fontPreview.appendChild(meta);
      }
    };

    if (fontChips) {
      fontsList.forEach((font) => {
        const chip = document.createElement('div');
        chip.className = 'font-chip';
        chip.textContent = font;
        chip.style.fontFamily = `'${font}', sans-serif`;
        chip.addEventListener('mouseenter', () => renderFontPreview(font));
        chip.addEventListener('click', () => {
          selectedFont = font;
          document.querySelectorAll('.font-chip').forEach(c => c.style.background = '#0d0d15');
          chip.style.background = '#26263a';
          renderFontPreview(font);
          if (pillFont) pillFont.textContent = font;
        });
        fontChips.appendChild(chip);
      });
      const firstFontChip = fontChips.querySelector('.font-chip');
      if (firstFontChip) {
        firstFontChip.style.background = '#26263a';
        renderFontPreview(selectedFont);
        if (pillFont) pillFont.textContent = selectedFont;
      }
    }

    if (debugToggle && debugPanel) {
      debugToggle.addEventListener('click', () => {
        const visible = debugPanel.style.display === 'block';
        debugPanel.style.display = visible ? 'none' : 'block';
        debugToggle.classList.toggle('debug-open', !visible);
        
        if (!visible) {
          const closeDebug = (e) => {
            if (!debugPanel.contains(e.target) && !debugToggle.contains(e.target)) {
              debugPanel.style.display = 'none';
              debugToggle.classList.remove('debug-open');
              document.removeEventListener('click', closeDebug);
            }
          };
          setTimeout(() => {
            document.addEventListener('click', closeDebug);
          }, 100);
        }
      });
    }

    const openOutputsFolder = async () => {
      if (window.electronAPI?.openFolder) {
        try {
          await window.electronAPI.openFolder('outputs');
        } catch (err) {
          console.error('Failed to open outputs folder:', err);
        }
      }
    };

    const openFolderBtn = document.getElementById('open-folder-btn');
    if (openFolderBtn) {
      openFolderBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        openOutputsFolder();
      });
    }

    if (viewerFrame) {
      viewerFrame.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        openOutputsFolder();
      });
    }

    const updateExecuteState = () => {
      const raw = cityInput?.value?.trim();
      const { city, country } = parseCityCountry(raw);
      const valid = !!city;
      executeBtn.disabled = !valid;
      if (!valid && cityError) {
        cityError.textContent = 'Please enter a city name';
      } else if (cityError) {
        cityError.textContent = '';
      }
    };

    const saveInputs = () => {
      const payload = {
        city: cityInput?.value || '',
        distance: distanceInput?.value || '12000',
        width: widthInput?.value || '12',
        height: heightInput?.value || '16',
        format: formatInput?.value || 'png',
        theme: selectedTheme,
        mapType: selectedMapType,
        font: selectedFont,
        texture: selectedTexture,
        mapShape: selectedMapShape,
      };
      try { localStorage.setItem('mapgen.form', JSON.stringify(payload)); } catch (e) { /* ignore */ }
    };

    const loadInputs = () => {
      try {
        const raw = localStorage.getItem('mapgen.form');
        if (!raw) return;
        const data = JSON.parse(raw);
        if (data.city) cityInput.value = data.city;
        if (data.distance) distanceInput.value = data.distance;
        if (data.width) widthInput.value = data.width;
        if (data.height) heightInput.value = data.height;
        if (data.format) formatInput.value = data.format;
        if (data.theme && themesMeta[data.theme]) selectedTheme = data.theme;
        if (data.mapType) {
          selectedMapType = Array.isArray(data.mapType) ? data.mapType : [data.mapType];
          // Clear defaults
           mapTypeToggle.querySelectorAll('.map-type-btn').forEach(b => b.classList.remove('active'));
           
           selectedMapType.forEach(type => {
              const btn = mapTypeToggle?.querySelector(`[data-type="${type}"]`);
              if (btn) btn.classList.add('active');
           });
           
           // Use the first selected type for distance presets, or default to city
           renderDistancePresets(selectedMapType[0] || 'city');
        }
        if (data.font && fontsList.includes(data.font)) selectedFont = data.font;
        if (data.texture) {
          selectedTexture = data.texture;
          if (textureSelect) textureSelect.value = data.texture;
        }
        if (data.mapShape) {
          selectedMapShape = data.mapShape;
          if (mapShapeSelect) mapShapeSelect.value = data.mapShape;
        }
      } catch (e) { /* ignore */ }
    };

    textureSelect?.addEventListener('change', (e) => {
      selectedTexture = e.target.value;
    });

    mapShapeSelect?.addEventListener('change', (e) => {
      selectedMapShape = e.target.value;
    });

    artisticEffectSelect?.addEventListener('change', (e) => {
      selectedArtisticEffect = e.target.value;
    });

    colorEnhancementSelect?.addEventListener('change', (e) => {
      selectedColorEnhancement = e.target.value;
    });

    const runExecute = async () => {
      const raw = cityInput?.value?.trim();
      const { city, country, state } = parseCityCountry(raw);
      if (!city) {
        setProgress(0, 'Enter a city name');
        if (cityError) cityError.textContent = 'Please enter a city name';
        return;
      }

      const finalCountry = country || '';

      
      if (!window.electronAPI?.generateMap) {
        setProgress(0, 'Electron API unavailable');
        return;
      }

      if (cityError) cityError.textContent = '';
      executeBtn.disabled = true;
      executeBtn.classList.add('loading');
      const originalLabel = executeBtn.textContent;
      executeBtn.textContent = 'Executing…';
      setProgress(8, 'Starting generator…');

      try {
        const distance = distanceInput?.value?.trim() || '29000';
        const width = widthInput?.value?.trim() || '12';
        const height = heightInput?.value?.trim() || '16';
        const format = formatInput?.value?.trim() || 'png';
        const mixerEnabled = document.getElementById('enable-mixer')?.checked || false;
        
        await window.electronAPI.generateMap({
          city,
          country: finalCountry,
          ...(state && { state }),
          theme: selectedTheme,
          mapType: selectedMapType,
          distance,
          width,
          height,
          format,
          font: selectedFont,
          styleRoads: mixerEnabled ? document.getElementById('style-roads').value : '',
          styleWater: mixerEnabled ? document.getElementById('style-water').value : '',
          styleParks: mixerEnabled ? document.getElementById('style-parks').value : '',
          styleTransit: mixerEnabled ? document.getElementById('style-transit').value : '',
          texture: selectedTexture,
          mapShape: selectedMapShape,
          artisticEffect: selectedArtisticEffect,
          colorEnhancement: selectedColorEnhancement,
        });

        // Immediate feedback for queue
        showToast('info', `Added "${city}" to queue`);
        executeBtn.disabled = false;
        executeBtn.textContent = originalLabel;
        executeBtn.classList.remove('loading');
        
      } catch (err) {
        console.error(err);
        setProgress(0, 'Error: see console');
        showToast('error', 'Failed to queue job');
        executeBtn.classList.remove('loading');
        executeBtn.textContent = originalLabel;
        executeBtn.disabled = false;
      }
    };
    
    // Listen for job completion
    window.electronAPI?.onJobComplete?.((data) => {
        if (data.success) {
            showToast('success', `Render complete: ${data.city}`);
            setProgress(100, `Finished: ${data.city}`);
        } else {
            showToast('error', `Render failed: ${data.city}`);
            setProgress(0, `Error: ${data.error}`);
        }
    });
    
    // Listen for queue updates
    window.electronAPI?.onQueueUpdate?.((status) => {
        const queueBadge = document.getElementById('queue-counter');
        
        if (status.active) {
            // Update queue counter
            if (queueBadge) {
                queueBadge.textContent = `AQ: ${status.count}`;
                queueBadge.classList.add('active');
                queueBadge.style.display = 'flex';
            }
            
            // Update status message but don't lock the button
            const statusText = status.current === 'Processing...' ? 'Processing...' : 'Queue Job';
            // Only update text if we aren't hovering or interacting (optional, but keep simple)
            
            if (status.current !== 'Idle' && status.current !== 'Processing...') {
                 statusMsg.textContent = `Generating: ${status.current}`;
            } else {
                 statusMsg.textContent = `Processing queue... (${status.count} remaining)`;
            }
        } else {
            statusMsg.textContent = 'System Ready';
            if (queueBadge) {
                queueBadge.textContent = 'AQ: 0';
                queueBadge.classList.remove('active');
                queueBadge.style.display = 'none';
            }
        }
    });


    executeBtn?.addEventListener('click', runExecute);
    const attachEnterToExecute = (el) => {
      if (!el) return;
      el.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          runExecute();
        }
      });
    };

    [cityInput, distanceInput, widthInput, heightInput, formatInput, textureSelect].forEach(el => {
      attachEnterToExecute(el);
      el?.addEventListener('input', () => { updateExecuteState(); saveInputs(); });
      el?.addEventListener('change', () => { updateExecuteState(); saveInputs(); });
    });

    if (swapSizeBtn) {
      swapSizeBtn.addEventListener('click', () => {
        const w = widthInput.value;
        widthInput.value = heightInput.value;
        heightInput.value = w;
        saveInputs();
      });
    }

    if (mapTypeToggle) {
      mapTypeToggle.querySelectorAll('.map-type-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const type = btn.dataset.type;
          
          if (selectedMapType.includes(type)) {
             // Avoid deselecting the last one? Or allow it? Let's ensure at least one.
             if (selectedMapType.length > 1) {
                 selectedMapType = selectedMapType.filter(t => t !== type);
                 btn.classList.remove('active');
             }
          } else {
             selectedMapType.push(type);
             btn.classList.add('active');
          }
          
          // Update presets based on the most recently added or first
          applyMapTypeDefaults(type); 
          saveInputs();
        });
      });
    }

    renderDistancePresets((Array.isArray(selectedMapType) ? selectedMapType[0] : selectedMapType) || 'city');

    loadInputs();
    updateExecuteState();
    if (pillTheme) pillTheme.textContent = selectedTheme;
    if (pillFont) pillFont.textContent = selectedFont;

    const uiThemes = [
      { key: 'synth', label: 'Synth Wave' },
      { key: 'dark', label: 'Dark' },
      { key: 'light', label: 'Light' },
      { key: 'contrast', label: 'High Contrast' },
    ];

    const applyUiTheme = (key) => {
      document.body.setAttribute('data-theme', key);
      try { localStorage.setItem('mapgen.uiTheme', key); } catch (e) { /* ignore */ }
      if (!uiThemeChips) return;
      uiThemeChips.querySelectorAll('.ui-theme-chip').forEach(chip => {
        chip.classList.toggle('active', chip.dataset.key === key);
      });
    };

    if (uiThemeChips) {
      uiThemes.forEach(({ key, label }) => {
        const chip = document.createElement('div');
        chip.className = 'ui-theme-chip';
        chip.dataset.key = key;
        chip.textContent = label;
        chip.addEventListener('click', () => applyUiTheme(key));
        uiThemeChips.appendChild(chip);
      });

      let savedTheme = 'synth';
      try { savedTheme = localStorage.getItem('mapgen.uiTheme') || 'synth'; } catch (e) { /* ignore */ }
      if (!uiThemes.find(t => t.key === savedTheme)) savedTheme = 'synth';
      applyUiTheme(savedTheme);
    }

    setProgress(0, 'Idle');
  </script>
</body>
</html>
